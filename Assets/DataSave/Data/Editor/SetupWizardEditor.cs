using System.Reflection;
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace SaveLoadSystem
{
    [CustomEditor(typeof(SetupWizard))]
    public class SetupWizardEditor : Editor
    {
        private SerializedProperty compressionProp;
        private SerializedProperty encryptionProp;
        private SerializedProperty autoGenerateProp;
        private SerializedProperty autoGeneratedSlotNameProp;
        private SerializedProperty saveSlotsProp;
        private SerializedProperty loggingDetailProp;

        private SetupWizard wizard;
        private Dictionary<string, bool> slotFoldouts = new Dictionary<string, bool>();
        private Vector2 scrollPosition;

        private static readonly Color lineColor = new Color(1f, 1f, 1f, 0.15f);
        private static readonly Color cacheBackgroundColor = new Color(0.2f, 0.2f, 0.2f, 0.3f);

        private void OnEnable()
        {
            compressionProp = serializedObject.FindProperty("_compression");
            encryptionProp = serializedObject.FindProperty("_encryption");
            autoGenerateProp = serializedObject.FindProperty("_autoGenerateSlot");
            autoGeneratedSlotNameProp = serializedObject.FindProperty("_autoGeneratedSlotName");
            saveSlotsProp = serializedObject.FindProperty("_saveSlots");
            loggingDetailProp = serializedObject.FindProperty("_loggingDetail");

            wizard = (SetupWizard)target;
            EditorApplication.update += UpdateSaveSlots;
        }

        private void OnDisable()
        {
            EditorApplication.update -= UpdateSaveSlots;
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            DrawSectionHeader("Security and Performance");
            EditorGUILayout.PropertyField(compressionProp);
            EditorGUILayout.PropertyField(encryptionProp);
            EditorGUILayout.Space(10);

            DrawSectionHeader("Ease of Use");
            EditorGUILayout.PropertyField(autoGenerateProp);

            if (autoGenerateProp.boolValue)
            {
                EditorGUILayout.PropertyField(autoGeneratedSlotNameProp);
            }
            EditorGUILayout.Space(10);

            DrawSectionHeader("Debugging");
            EditorGUILayout.PropertyField(loggingDetailProp);
            EditorGUILayout.Space(10);

            // Draw save slots with cache data
            DrawSaveSlots();

            // Button to clear all save files (only in edit-mode)
            if (!Application.isPlaying)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Delete All Save Slots", GUILayout.Width(200)))
                {
                    DataManager.DeleteAllSaveSlots();
                    typeof(SetupWizard)
                        .GetField("_saveSlots", BindingFlags.NonPublic | BindingFlags.Instance)
                        ?.SetValue(wizard, new SaveSlot[0]);

                    EditorUtility.SetDirty(wizard);
                }
                GUILayout.FlexibleSpace();
                EditorGUILayout.EndHorizontal();
            }

            serializedObject.ApplyModifiedProperties();
        }

        private void DrawSaveSlots()
        {
            DrawSectionHeader("Save Slots");
            
            if (!Application.isPlaying)
            {
                EditorGUILayout.LabelField("Save slot data is only available during runtime.", EditorStyles.helpBox);
                return;
            }

            var saveSlots = DataManager.GetSaveSlots();
            
            if (saveSlots == null || saveSlots.Count == 0)
            {
                EditorGUILayout.LabelField("No save slots found.");
                return;
            }

            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.MaxHeight(400));

            foreach (var slot in saveSlots)
            {
                DrawSaveSlot(slot);
            }

            EditorGUILayout.EndScrollView();
        }

        private void DrawSaveSlot(SaveSlot slot)
        {
            if (slot == null) return;

            // Initialize foldout state if not exists
            if (!slotFoldouts.ContainsKey(slot.Name))
            {
                slotFoldouts[slot.Name] = false;
            }

            // Draw slot header with background
            Rect headerRect = EditorGUILayout.GetControlRect(false, 25);
            EditorGUI.DrawRect(headerRect, cacheBackgroundColor);
            
            // Foldout for the slot
            bool wasExpanded = slotFoldouts[slot.Name];
            slotFoldouts[slot.Name] = EditorGUI.Foldout(
                new Rect(headerRect.x + 5, headerRect.y + 5, headerRect.width - 10, 15),
                slotFoldouts[slot.Name], 
                $"{slot.Name} ({GetSlotInfo(slot)})",
                true
            );

            if (slotFoldouts[slot.Name])
            {
                EditorGUI.indentLevel++;
                
                // Slot metadata
                EditorGUILayout.LabelField("Compression:", slot.CompressionType.ToString());
                EditorGUILayout.LabelField("Encryption:", slot.EncryptionType.ToString());
                EditorGUILayout.LabelField("File Size:", FormatFileSize(slot.GetFileSize()));
                EditorGUILayout.LabelField("Last Modified:", slot.GetLastModified().ToString("yyyy-MM-dd HH:mm:ss"));
                
                EditorGUILayout.Space(5);
                
                // Cache data
                DrawCacheData(slot);
                
                EditorGUI.indentLevel--;
                EditorGUILayout.Space(5);
            }
        }

        private void DrawCacheData(SaveSlot slot)
        {
            try
            {
                var cacheData = slot.GetCacheData();
                
                if (cacheData == null || cacheData.Count == 0)
                {
                    EditorGUILayout.LabelField("Cache Data:", "Empty");
                    return;
                }

                EditorGUILayout.LabelField($"Cache Data: ({cacheData.Count} entries)");
                
                EditorGUI.indentLevel++;
                
                foreach (var kvp in cacheData)
                {
                    DrawCacheEntry(kvp.Key, kvp.Value);
                }
                
                EditorGUI.indentLevel--;
            }
            catch (System.Exception ex)
            {
                EditorGUILayout.LabelField("Cache Data:", $"Error: {ex.Message}");
            }
        }

        private void DrawCacheEntry(string key, object value)
        {
            EditorGUILayout.BeginHorizontal();
            
            // Key
            EditorGUILayout.LabelField(key, GUILayout.Width(150));
            
            // Value (formatted)
            string valueString = FormatValue(value);
            EditorGUILayout.LabelField(valueString, EditorStyles.wordWrappedLabel);
            
            EditorGUILayout.EndHorizontal();
        }

        private string FormatValue(object value)
        {
            if (value == null) return "null";
            
            try
            {
                // Try to format as JSON for complex objects
                if (value is string str)
                {
                    return $"\"{str}\"";
                }
                
                if (value.GetType().IsPrimitive || value is decimal)
                {
                    return value.ToString();
                }
                
                // For complex objects, try to serialize them nicely
                string json = JsonConvert.SerializeObject(value, JsonConverters.JsonSettings);
                
                return json;
            }
            catch
            {
                return value.ToString();
            }
        }

        private string GetSlotInfo(SaveSlot slot)
        {
            try
            {
                var cacheData = slot.GetCacheData();
                int entryCount = cacheData?.Count ?? 0;
                return $"{entryCount} entries";
            }
            catch
            {
                return "error";
            }
        }

        private string FormatFileSize(long bytes)
        {
            if (bytes == 0) return "0 B";
            
            string[] sizes = { "B", "KB", "MB", "GB" };
            int order = 0;
            double size = bytes;
            
            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }
            
            return $"{size:0.##} {sizes[order]}";
        }

        private void DrawSectionHeader(string title)
        {
            EditorGUILayout.Space(10);
            EditorGUILayout.LabelField(title, EditorStyles.boldLabel);

            Rect lastRect = GUILayoutUtility.GetLastRect();
            Rect lineRect = new Rect(lastRect.x, lastRect.yMax + 2f, lastRect.width, 1f);
            EditorGUI.DrawRect(lineRect, lineColor);

            EditorGUILayout.Space(8);
        }

        private void UpdateSaveSlots()
        {
            if (!Application.isPlaying) return;

            var saveSlots = DataManager.GetSaveSlots();
            typeof(SetupWizard)
                .GetField("_saveSlots", BindingFlags.NonPublic | BindingFlags.Instance)
                ?.SetValue(wizard, saveSlots.ToArray());

            if (wizard != null)
                EditorUtility.SetDirty(wizard);
        }
    }
}